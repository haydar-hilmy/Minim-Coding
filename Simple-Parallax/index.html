<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Parallax</title>
</head>

<style>
  * {
    scroll-behavior: smooth;
    font-family: Helvetica, sans-serif;
  }

  body {
    margin: 0;
    background-color: #161616;
    color: #e9e9e9;
  }

  section {
    height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 0 10%;

  }

  section h1 {
    margin: 20px 0;
  }

  section p {
    margin: 0;
    line-height: 150%;
  }

  .parallax {
    transform: translateX(-30%);
    transition-duration: 800ms;
    opacity: 0;
}

.show {
    opacity: 1;
    transform: translateX(0);
  }
</style>

<body>

  <section class="parallax">
    <h1>This is a simple parallax effect.</h1>
    <p>Tentu, Intersection Observer tidak hanya berguna untuk animate on scrolling. Dengan sedikit kreativitas, kita bisa memanfaatkannya untuk menciptakan efek parallax yang lebih dinamis dan keren!</p>
  </section>
  <section class="parallax">
    <h1>This is a simple parallax effect.</h1>
    <p>Tentu, Intersection Observer tidak hanya berguna untuk animate on scrolling. Dengan sedikit kreativitas, kita bisa memanfaatkannya untuk menciptakan efek parallax yang lebih dinamis dan keren!</p>
  </section>
  <section class="parallax">
    <h1>This is a simple parallax effect.</h1>
    <p>Tentu, Intersection Observer tidak hanya berguna untuk animate on scrolling. Dengan sedikit kreativitas, kita bisa memanfaatkannya untuk menciptakan efek parallax yang lebih dinamis dan keren!</p>
  </section>


  <script>
    document.addEventListener("DOMContentLoaded", function() {
      const parallaxElements = document.querySelectorAll(".parallax");

      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add('show')
            } else {
              entry.target.classList.remove('show')
            }
          });
        }, {
          threshold: 0.4
        }
      );

      parallaxElements.forEach((element) => observer.observe(element));
    });
  </script>
</body>

</html>